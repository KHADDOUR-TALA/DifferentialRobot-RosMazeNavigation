Overview:
    This package is used to model a differential robot with a Lidar sensor. It simulates the Lidar data, and then control it to escape a five layer arbitrary maze.
    Moreover, Rvis environment was used to visualize the robot, maze, and the overall process of escaping showing the traversed path.
    Lastly, a service was used to reset the pose of the robot to (0,0,0)
Authors:
    Tala Khadour
    Zain Soliman
Installation:
    The maze_marker_publisher node is generated by lidar_data.py file and it publishes the maze which is a list of tuples representing straight lines with the form (x_1,y_1,x_2,y_2)
	joint_state_publisher: publishes the angles/positions of the robot’s joints (e.g., wheel rotations) as a sensor_msgs/JointState message.
	robot_state_publisher: compute and publish the full transform (TF) tree of your robot based on the URDF + incoming /joint_states
	The simulated_lidar node is generated by the broad_lidar.py file and its job to calculate how would the readings of the lidar would be according to the robot’s pose. In short it is to simulate the lidar sensor’s data which are published on the “scan” topic
	The maze_navigator node is generated by the broad_robot.py file. It subscribes to the scaned data from the lidar and use them to control the robot. It also publishes the path of the robot to visualize it in Rviz and updates the robot’s poses by broadcasting a tf between the ‘base_link’ frame and the ‘world’ fram to move the robot.
Usage:
    run the rviz_launch.launch to begin the simulation. To reset the pose of the robot run client.py separately and the simulation will restart from the middle of the five layers maze
